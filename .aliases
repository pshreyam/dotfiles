# Get coloured output
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias grep='grep --color=auto'
    alias diff='diff --color=auto'
    alias ip='ip --color=auto'
fi

alias history="history 0" # force zsh to show the complete history
alias ll='ls -alF'
alias la='ls -a'

# Interactive command aliases
alias mv='mv -i'
alias cp='cp -i'
alias rm='rm -i'

# Config files aliases
alias cb="$EDITOR ~/.config/bspwm/bspwmrc"
alias cs="$EDITOR ~/.config/sxhkd/sxhkdrc"
alias cpol="$EDITOR ~/.config/polybar/config.ini"
alias cdun="$EDITOR ~/.config/dunst/dunstrc"
alias cpic="$EDITOR ~/.config/picom/picom.conf"
alias crof="$EDITOR ~/.config/rofi/config.rasi"
alias czat="$EDITOR ~/.config/zathura/zathurarc"
alias cnvi="$EDITOR ~/.config/nvim/init.lua"
alias cali="$EDITOR ~/.aliases"
alias cz="$EDITOR ~/.zshrc"
alias calac="$EDITOR ~/.config/alacritty/alacritty.toml"
alias ctmx="$EDITOR ~/.config/tmux/tmux.conf"
alias bm="$EDITOR ~/.scripts/bookmarks/bookmarks.json"
alias chy="$EDITOR ~/.config/hypr/hyprland.conf"

# Aliases
alias vi=$EDITOR
alias nnn='nnn -de'
alias trash='send2trash'

# Directory navigation (go to directory) aliases
alias gg='cd ~'
alias gdc='cd ~/Documents'
alias gdn='cd ~/Downloads'
alias gco="cd $CODE_DIR"
alias gr="cd $CODE_DIR/repos"

# Replacement program aliases
alias ls="eza"
alias cat='bat -p'

# Source env from shell script
alias source_env='source ~/Work/env.sh'

# Manage dotfiles
function dotfiles() {
    git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME $@
}

function cr() {
    # Define base folders to search for repositories
    base_folders=(~/Work/repos ~/Code/repos)

    # Find all git repositories recursively (max depth 3)
    repos=()
    for folder in "${base_folders[@]}"; do
        # Expand the folder path
        folder=$(eval echo "$folder")

        # Check if folder exists
        if [[ -d "$folder" ]]; then
            # Find directories containing .git folder, max depth 3
            while IFS= read -r repo; do
                repos+=("$repo")
            done < <(find "$folder" -maxdepth 3 -type d -name ".git" 2>/dev/null | sed 's|/\.git$||' | sort)
        fi
    done

    # Check if any repositories were found
    if [[ ${#repos[@]} -eq 0 ]]; then
        echo "No git repositories found."
        return 0
    fi

    # Create a formatted list for fzf
    # Show relative paths from home directory for better readability
    formatted_repos=()
    for repo in "${repos[@]}"; do
        # Replace home directory with ~
        formatted_repo="${repo/#$HOME/~}"
        formatted_repos+=("$formatted_repo")
    done

    # Use fzf to select a repository
    selected=$(printf '%s\n' "${formatted_repos[@]}" | fzf \
        --border=rounded \
        --height=50% \
        --layout=reverse \
        --header="Choose a git repository" \
        --header-first \
        --prompt="› " \
        --pointer="➜" \
        --preview='echo "📁 Repository: {}" && echo "" && ls -la $(eval echo {}) 2>/dev/null | head -20')

    # If no repository is chosen, exit the function
    if [[ -z $selected ]]; then
        echo "No repository selected."
        return 0
    fi

    # Expand the selected path (convert ~ back to $HOME)
    selected_path=$(eval echo "$selected")

    echo "Changed directory to $selected_path"

    # Change directory to the chosen repository
    cd "$selected_path"
}

# Message to a particular webhook
function message-webhook() {
    message="$@"
    curl -X POST -H 'Content-type: application/json' -d "{\"content\": \"$message\", \"embeds\": null, \"attachments\": []}" $WEBHOOK_URL
}
